import dotenv from "dotenv";
import { google } from "googleapis";
import nodemailer from "nodemailer";
import fs from "fs";
import path from "path";
import { fileURLToPath } from 'url';
import XLSX from "xlsx";

// Configure __dirname equivalent for ES modules
const __filename = fileURLToPath(import.meta.url);
const __dirname = path.dirname(__filename);

dotenv.config();

// Load email credentials from environment variables
const EMAIL_USER = process.env.EMAIL_USER;
const EMAIL_PASS = process.env.EMAIL_PASS;
const GOOGLE_SHEET_ID = process.env.GOOGLE_SHEET_ID;
const GOOGLE_SERVICE_ACCOUNT_EMAIL = process.env.GOOGLE_SERVICE_ACCOUNT_EMAIL;
const GOOGLE_PRIVATE_KEY = process.env.GOOGLE_PRIVATE_KEY.replace(/\\n/g, "\n");

// Sheet ID from the provided link
const SHEET1_ID = 0;

// Create a JWT auth client and initialize the Sheets API
const auth = new google.auth.JWT(
  GOOGLE_SERVICE_ACCOUNT_EMAIL,
  null,
  GOOGLE_PRIVATE_KEY,
  ["https://www.googleapis.com/auth/spreadsheets"]
);
const sheets = google.sheets({ version: "v4", auth });

// Load the tailored email content from the JSON file generated by Email_Tailor.py
function loadTailoredEmailContent() {
  try {
    // Use absolute path to the updated email content file
    const filePath = path.join(__dirname, 'Frontend', 'email_content_mapping_updated.json');
    console.log(`Looking for email content at: ${filePath}`);
    
    if (fs.existsSync(filePath)) {
      const rawData = fs.readFileSync(filePath);
      const emailMapping = JSON.parse(rawData);
      console.log(`Loaded tailored email content for ${Object.keys(emailMapping).length} recipients.`);
      return emailMapping;
    } else {
      console.log('Tailored email content file not found at path:', filePath);
      console.log('Checking alternative path...');
      
      // Try an alternative path as fallback
      const altPath = 'C:\\Users\\keyan\\OneDrive\\Documents\\recruiter-emailer\\Frontend\\email_content_mapping_updated.json';
      console.log(`Checking alternative path: ${altPath}`);
      
      if (fs.existsSync(altPath)) {
        const rawData = fs.readFileSync(altPath);
        const emailMapping = JSON.parse(rawData);
        console.log(`Loaded tailored email content from alternative path for ${Object.keys(emailMapping).length} recipients.`);
        return emailMapping;
      }
      
      console.log('No tailored email content found in any location. Using default templates.');
      return {};
    }
  } catch (error) {
    console.error('Error loading tailored email content:', error);
    return {};
  }
}

// Function to clean up email content by removing anything after "regards" and keeping "Regards" line as part of the email body
function cleanEmailContent(content) {
  if (!content) return content;
  
  // Find "regards" (case-insensitive) and remove everything after it
  const regardsIndex = content.search(/\b(regards|regard)\b/i);
  if (regardsIndex !== -1) {
    // Ensure "Regards" line is preserved
    const beforeRegards = content.substring(0, regardsIndex).trim();
    const afterRegards = content.substring(regardsIndex).split(/\n|<br>/)[0].trim();
    return `${beforeRegards}\n${afterRegards}`;
  }
  
  return content.trim();
}

// Function to format the email content with proper signature to avoid Gmail detection issues
function formatEmailWithSignature(name, content, isCustom) {
  let emailBody;
  
  // Use custom content or default
  if (isCustom) {
    emailBody = cleanEmailContent(content);
  } else {
    emailBody = content;
  }
  
  // Format with proper HTML to avoid Gmail signature detection
  // Using a table layout and specific styling to prevent signature detection
  return `<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Email</title>
</head>
<body style="font-family: Arial, sans-serif; line-height: 1.6; color: #333333;">
  <table width="100%" cellpadding="0" cellspacing="0" border="0">
    <tr>
      <td>
        <div style="margin-bottom: 10px;">Dear ${name},</div>
        
        <div style="margin-bottom: 20px;">${emailBody.replace(/<br><br>/g, '</div><div style="margin-bottom: 20px;">')}</div>
        
        <!-- This non-breaking space helps prevent Gmail from detecting the signature -->
        <div style="margin-top: 10px;">&nbsp;</div>
        
        <!-- Signature with non-standard formatting to avoid Gmail's signature detection -->
        <div style="margin-top: 15px;">
          <span style="display: inline-block;">Regards,</span>
        </div>
        <div style="margin-top: 5px;">
          <span style="display: inline-block; font-weight: 500;">Keyanshu Gariba</span> |
          <span style="display: inline-block;">+1 (857) 492-8869</span> |
          <a href="https://www.linkedin.com/in/keyanshu/" style="color: #0077B5; text-decoration: underline;">LinkedIn Profile</a>
        </div>
      </td>
    </tr>
  </table>
</body>
</html>`;
}

// New function to load recruiters from Sheet1 in Google Sheets
async function loadRecruitersFromSheet() {
  try {
    const response = await sheets.spreadsheets.values.get({
      spreadsheetId: GOOGLE_SHEET_ID,
      range: "Sheet1!A2:Z"  // Assuming columns A to Z, adjust as needed
    });
    
    const rows = response.data.values;
    if (!rows || rows.length === 0) {
      console.log("No data found in Sheet1.");
      return [];
    }
    
    // Convert rows to objects (assuming first row contains headers)
    const headers = ["Name", "Email", "Company"];
    const recruiters = rows.map(row => {
      const recruiter = {};
      headers.forEach((header, index) => {
        recruiter[header] = row[index];
      });
      return recruiter;
    });
    
    console.log(`Loaded ${recruiters.length} recruiters from Google Sheets.`);
    return recruiters;
  } catch (error) {
    console.error("Error loading recruiters from Google Sheets:", error);
    return [];
  }
}

// Function to load already sent emails from the "k_done" sheet
async function loadSentEmails() {
  try {
    // Adjust the range as needed. Here we assume email addresses are in column B.
    const response = await sheets.spreadsheets.values.get({
      spreadsheetId: GOOGLE_SHEET_ID,
      range: "k_done!B:B" // Change "k_done" if your tab has a different name.
    });
    const rows = response.data.values;
    const sentEmails = new Set();
    if (rows && rows.length) {
      // Assuming the first row is a header; adjust if not.
      rows.slice(1).forEach(row => {
        if (row[0]) {
          sentEmails.add(row[0]);
        }
      });
    }
    return sentEmails;
  } catch (error) {
    console.error("Error retrieving sheet data:", error);
    return new Set();
  }
}

// Function to transfer successful emails to k_done sheet and remove from current sheet
async function transferAndRemoveFromSheet(recruiter, rowIndex, isDuplicate = false) {
  try {
    let rowData = [];

    // Prepare row data with all columns
    const sheet1Response = await sheets.spreadsheets.values.get({
      spreadsheetId: GOOGLE_SHEET_ID,
      range: "Sheet1!A2:Z" // Assuming columns A to Z, adjust as needed
    });

    const sheet1Rows = sheet1Response.data.values;
    if (!sheet1Rows || sheet1Rows.length === 0) {
      return;
    }

    // Find the row index with matching email
    const emailColIndex = 1; // Email is in column B (index 1)
    for (let i = 0; i < sheet1Rows.length; i++) {
      if (sheet1Rows[i][emailColIndex] === recruiter.Email) {
        rowIndex = i + 1; // Adjust for 0-based index
        rowData = sheet1Rows[i]; // Get the entire row data
        break;
      }
    }

    if (rowIndex === -1) {
      console.error(`Could not find row with email ${recruiter.Email} in Sheet1`);
      return;
    }

    if (!isDuplicate) {
      // Append the data to k_done sheet
      await sheets.spreadsheets.values.append({
        spreadsheetId: GOOGLE_SHEET_ID,
        range: "k_done!A:Z", // Assuming columns A to Z, adjust as needed
        valueInputOption: "USER_ENTERED",
        insertDataOption: "INSERT_ROWS",
        resource: {
          values: [rowData] // Ensure all columns are transferred
        }
      });
    }

    if (!isDuplicate) {
      console.log(`Successfully transferred ${recruiter.Email} to k_done sheet.`);
    } else {
      console.log(`Duplicate email ${recruiter.Email} was not transferred.`);
    }
  } catch (error) {
    console.error(`Error transferring ${recruiter.Email} to k_done sheet:`, error);
  }
}

// Configure Nodemailer
const transporter = nodemailer.createTransport({
  service: "gmail",
  auth: {
    user: EMAIL_USER,
    pass: EMAIL_PASS,
  },
});

// Email sending function
async function sendEmail(recruiter, rowIndex, sentEmails, tailoredEmails) {
  const { Name, Email, Company } = recruiter;

  // Check for duplicate email
  if (sentEmails.has(Email)) {
    console.error(`Error: Duplicate email found for ${Email}. Deleting from Sheet1.`);
    await transferAndRemoveFromSheet(recruiter, rowIndex, true);
    return;
  }

  const subject = `Exploring opportunities at ${Company}`;
  
  // Use tailored email content if available, otherwise use default content
  let body;
  if (tailoredEmails && tailoredEmails[Email]) {
    body = formatEmailWithSignature(Name, tailoredEmails[Email], true);
    console.log(`Using tailored email content for ${Email}`);
  } else {
    const defaultContent = `I hope this email finds you well. My name is Keyanshu Gariba, and I am a graduate student at Northeastern University (Boston campus), set to graduate this May. With a strong background in software engineering, including Full Stack Development, Database Management, and Generative AI, I am eager to apply my skills and knowledge in a professional setting.<br><br>
I would greatly appreciate your consideration for any open Software Development or Data Engineering positions within your organization. I have attached my resume for your reference and would be happy to provide any additional information if needed.`;
    body = formatEmailWithSignature(Name, defaultContent, false);
    console.log(`No tailored content found for ${Email}, using default template.`);
  }

  const mailOptions = {
    from: `"Keyanshu Gariba" <${EMAIL_USER}>`,
    to: Email,
    subject: subject,
    html: body,
    attachments: [
      {
        filename: "KeyanshuGariba_Resume.pdf",
        path: path.join(__dirname, "KeyanshuGariba_Resume.pdf"),
      },
    ],
  };

  try {
    await transporter.sendMail(mailOptions);
    console.log(`Email sent to ${Email} (${Company})`);
    
    // After successfully sending the email, transfer it to k_done sheet and remove from Sheet1
    await transferAndRemoveFromSheet(recruiter, rowIndex);
    
    // Add the email to the sentEmails Set to avoid duplicates in the current run
    sentEmails.add(Email);
  } catch (error) {
    console.error(`Failed to send email to ${Email}:`, error.message);
  }
}

// Function to clear the email_content_mapping_updated.json file
function clearEmailContentFile() {
  try {
    // Try both possible paths to the file
    const filePath = path.join(__dirname, 'Frontend', 'email_content_mapping_updated.json');
    const altPath = 'C:\\Users\\keyan\\OneDrive\\Documents\\recruiter-emailer\\Frontend\\email_content_mapping_updated.json';
    
    // Check which path exists and clear that file
    if (fs.existsSync(filePath)) {
      console.log(`Clearing email content file at: ${filePath}`);
      fs.writeFileSync(filePath, JSON.stringify({}), 'utf8');
      console.log('Email content file has been cleared successfully.');
    } else if (fs.existsSync(altPath)) {
      console.log(`Clearing email content file at alternative path: ${altPath}`);
      fs.writeFileSync(altPath, JSON.stringify({}), 'utf8');
      console.log('Email content file has been cleared successfully.');
    } else {
      console.log('No email content file found to clear.');
    }
  } catch (error) {
    console.error('Error clearing email content file:', error);
  }
}

// Function to send emails in batches of 5 with a 1-minute delay
async function sendEmailsInBatches() {
  const sentEmails = await loadSentEmails();
  const recruiters = await loadRecruitersFromSheet();
  const tailoredEmails = loadTailoredEmailContent();
  const batchSize = 5;
  const delay = 60000; // 1 minute in milliseconds

  for (let i = 0; i < recruiters.length; i += batchSize) {
    const batch = recruiters.slice(i, i + batchSize);
    const promises = batch.map((recruiter, index) =>
      sendEmail(recruiter, i + index + 1, sentEmails, tailoredEmails) // Pass tailoredEmails
    );
    await Promise.all(promises);
    if (i + batchSize < recruiters.length) {
      console.log(`Waiting for 1 minute before sending the next batch...`);
      await new Promise(resolve => setTimeout(resolve, delay));
    }
  }
  
  // After all emails are sent, clear the email content file
  console.log('All emails have been sent. Clearing email content file...');
  clearEmailContentFile();
}

// Replace the call to sendAllEmails with sendEmailsInBatches
sendEmailsInBatches();
